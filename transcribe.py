#https://towardsdatascience.com/speech-recognition-with-timestamps-934ede4234b2
#pip install youtube_transcript_api #this is just for the transcript stuff that is there generated by google.  
#pip install vosk
#pip install ffmpeg
#choco install ffmpeg
#pip install moviepy
#pip install pydub
#pip install speechrecognition
#https://alphacephei.com/vosk/models
import wave
import json
import moviepy.editor as mp
from vosk import Model, KaldiRecognizer, SetLogLevel
import Word as custom_Word
from pydub import AudioSegment
from os import path
import subprocess
import glob
import os
import speech_recognition as sr
import math




def get_timestamp(s):
    mins = math.floor(s/60)
    secs = math.floor(s - mins*60)
    filler = ""
    if secs < 10:
        filler = "0"
    return str(mins) + ":" + filler + str(secs)
    
def transcribe_me(filename):
    fn = filename.split('.')

    my_clip = mp.VideoFileClip(filename)

    temp_file = fn[0] + ".mp3"
    my_clip.audio.write_audiofile(temp_file)

    #subprocess.call(['ffmpeg', '-i', temp_file + ".mp3",
    #                   temp_file + ".wav"])

    audio_filename = fn[0] + ".wav"
    txt_filename = fn[0] + ".txt"

    sound = AudioSegment.from_mp3(temp_file)
    sound.export(audio_filename, format="wav")
    audio = AudioSegment.from_file(audio_filename, format="wav", frame_rate=44100)
    audio = audio.set_channels(1)
    audio = audio.set_frame_rate(16000)
    audio.export(audio_filename, format="wav")    
    
    #this is much more accurate but has no timestamps.  
    r = sr.Recognizer()
    test = sr.AudioFile(audio_filename)
    audio_length = audio.duration_seconds
    print(audio_length)
    segment_length = 20
    number_of_iterations = int(audio_length/segment_length)
    audior = []
    text = []
    times = []
    for i in range(number_of_iterations):
        with test as source:
            audior.append(r.record(source, offset=i*segment_length, duration=segment_length))
    for i in range(number_of_iterations):
        print(audior[i])
        try:
            text.append(r.recognize_google(audior[i], show_all=False)) 
            times.append(get_timestamp(i*segment_length))
            #print(text) 
        except Exception as e:
            print(e)
            
    f = open(txt_filename, "w")
    for i in range(len(text)):
        print(times[i])
        print(text[i]) 
#        f.write(times[i] + '\n')
        f.write(text[i] + ' (' + times[i] + ')\n')
    f.close()
    vosk = """
    model_path = "../models/vosk-model-en-us-0.22"

    model = Model(model_path)
    wf = wave.open(audio_filename, "rb")
    rec = KaldiRecognizer(model, wf.getframerate())
    rec.SetWords(True)

    # get the list of JSON dictionaries
    results = []
    # recognize speech using vosk model
    while True:
        data = wf.readframes(4000)
        if len(data) == 0:
            break
        if rec.AcceptWaveform(data):
            part_result = json.loads(rec.Result())
            results.append(part_result)
    part_result = json.loads(rec.FinalResult())
    results.append(part_result)

    # convert list of JSON dictionaries to list of 'Word' objects
    list_of_words = []
    for sentence in results:
        if len(sentence) == 1:
            # sometimes there are bugs in recognition 
            # and it returns an empty dictionary
            # {'text': ''}
            continue
        for obj in sentence['result']:
            w = custom_Word.Word(obj)  # create custom Word object
            list_of_words.append(w)  # and add it to list

    wf.close()  # close audiofile

    # output to the screen
    f = open(txt_filename, "w")
    for word in list_of_words:
        print(word.to_string())
        f.write(word.to_string())
        
    f.close()
    """    
if __name__ == '__main__':
    list_of_files = glob.glob('C:/Users/devin/Videos/*.mkv') # * means all if need specific format then *.csv
    latest_file = max(list_of_files, key=os.path.getctime)
    print(latest_file)
    #transcribe_me(latest_file)
    transcribe_me(r"C:\Users\devin\Videos\2023-02-11 11-23-44.mkv")