Lets use this modus operandi for watching on one machine and creating on the other.  
This will be a useful way to do things.  

**web/public/analyze.html
Cant do autosave, but perhaps remind after certain period of time.  
Also make sure we can save and then resave.  This is what is preventing.  
Need to make sure update and re-update works.  I think we have already tested this
in a rudimentary way.  

**web/public/chat.html
webrtc

**web/public/watch.html
Show watch list.  Show video details, are we able to get, I forget.  
Save where left off.  Update the RTDB every minute or so if watching.  
Same for analyze.html?  Only save video timer.  


**web/public/history.html
Show created list along with search filter. 
Search filter needs to search the transcripts as well. 
Just load everything and use javascript?  
For now this is ok, but perhaps need a better solution.  

**web/public/users.html
Only visible to logged in users.  
How many comments, review time.  
Inside of here, show preference.  
Per user, there will be "favorite" or similar mechanism.  
NxN map, just store favorites and then have a calculation.  
Just allow for similar to thumbs up feature and track this with some statistics
likes / opportunities
If there is no commentary by any of the likes, just take a somewhat random sample.  
Again calculated by likes / opportunities



**web/public/language.html
How do we utilize this along with 
**languages/**.py

This is a significant architectural decision how we structure the language.  
Definitely need some logic, but can it be encoded? 
We can think of it perhaps like the .py includes the verbs and 
all of the management from html page is the nouns and modifiers.  
This allows us to grow in two distinct ways using different programmatic mechanisms.  
Good for experimentation.  



Need a feedback process.  
Reinforcement Learning From Human Feedback (RLHF)
This is key.  
https://huggingface.co/docs/trl/quickstart

This looks interesting, but we need to utilize the midi feedback
in order to train the model, and this will need to be based on the 
feedback language.  
So similarly for the UI interface we will need to use a *.py, 
we also need this same sort of structure for

**server/llmtune/server.py
for each feedback language we perhaps need a *.py
in order to ingest properly.  
Perhaps just pass the model.  
*.py -> train(model, feedback)

